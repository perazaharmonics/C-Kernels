/**
 * This program demonstrates the nonreentrant nature of crypt() function (Section 8.5).
 * As cmd-line arguments, this program accepts two strings. The program performs the
 * following steps: 
 * 1. Call crypt() to encrypt the string in the first cmd-line argument, and copy
 *     this string using the strdup().
 * 2. Establish a handler for SIGINT (generated by typing Ctrl +C). The handler
 *     calls crypt() to encrypt the string supplied in the second cmd-line argument.
 * 3. Enter an infinite for loop that uses crypt() to encrypt the string in the cmd
 *     line argument and check that the returned string is the same as that saved in
 *     step 1.
 * In absence of a signal the string will always match step 3. ... Comparing the
 * mismatched and handled, we see that a majority of the cases where the signal
 * handler is invoked, it overwrites the statically allocated buffer between the call
 * to crypt() and the string comparison in main(). 
*/
#define _XOPEN_SOURCE 600
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include "tlpi_hdr.h"

static char* str2;                      // Set from argv[2]
static int handled=0;                   // Count number of calls to handler.

static void handler (                   // Function to handle Events generated.
  int sig)                              // The signal of the event.
{
  crypt(str2, "xx");                    // The string to encode.
  handled++;                            // Count we handled this signal.
}

int main (
  int argc,                             // The argument count.
  char* argv[])                         // The variable argument list.
{
  char* cr1;                            // Copy of encrypted string.
  int callNum;                          // The number of the call.
  int mismatch;                         // Number of encryption mismatches.
  struct sigaction sa;                  // The sigaction structure.
  
  if (argc != 3)                        // Not three arguments?
    usageErr("%s str1 str2.\n",argv[0]);// Print help.
  str2 = argv[2];                       // Make argv[2] available to the handler.
    // -------------------------------- //
    // Copy statically allocated string
    // -------------------------------- //
  cr1=strdup(crypt(argv[1], "xx"));     // 
  if (cr1 == NULL)                      // Could we copy the crytpic string ?
    errExit("strdup");                  // No, exit.
  sigemptyset(&sa.sa_mask);             // Blank out our bit mask.
  sa.sa_flags = 0;                      // No flags set.
  sa.sa_handler = handler;              // The signal handler.
  if (sigaction(SIGINT, &sa, NULL) == -1)// Could we change the signal action?
    errExit("sigaction");               // No, that's an error.
    // -------------------------------- //
    // Repeatedly call crypt() using argv[1]. If interrupted by a 
    // signal handler, then the static storage returned by crypt()
    // will be overwritten by the results of encrypting argv[2], and
    // strcmp() will detect a mismatch with the value in 'cr1'.
    // -------------------------------- //
  for (callNum = 1, mismatch = 0; ; callNum++)// For the amount of times called
    if (strcmp(crypt(argv[1], "xx"), cr1) != 0)// Are the encoded strings same?
    {                                   // No, that's countable.
      mismatch++;                       // Count the mismatch.
      printf("Mismatch on call %d"      // Report it.
        "(mismatch=%d handled=%d).\n",
        callNum, mismatch, handled);
    }
}
