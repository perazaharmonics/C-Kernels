/** Demonstrates the use of O_DIRECT while opening a file for reading. This
* program takes four command-line arguments specifying in order the file to be
* read, the number of bytes to read from the file, the offset to which the
* program should seek before reading from the file, and the alignment of the 
* data buffer passed to read(). The last two arguments are optional, and default
* offset to 0 and 4096 bytes.
*/

#define _GNU_SOURCE                     // Obtain O_DIRECT definition from <fcnt.h>.
#include <fcntl.h>
#include <malloc.h>
#include "tlpi_hdr.h"

int main (
  int argc,
  char* argv[])
{
  int fd0;                              // The file to read from 
  ssize_t nBytes;                       // The number of bytes read.
  size_t len;                           // Length of data to be transferred.
  size_t alignment;                     // Alignment of data buf passed to read.
  off_t ofs;                            // The offset to begin reading from.
  char* buf;                            // The processing buffer.
  // ---------------------------------- //
  // Verify if user wants help.
  // ---------------------------------- //
  if (argc < 3 || strcmp(argv[1],"--help") == 0)
    usageErr("%s file length [offset [alignment]].\n",
      argv[0]);
  // ---------------------------------- //
  // Process remainig of input arguments.
  // ---------------------------------- //
  len=getInt(argv[2], GN_ANY_BASE, "length");// Get expected file length.
  ofs=(argc > 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0;// Get offset to seek.
  alignment=(argc >4) ?  getLong(argv[4], GN_ANY_BASE, "alignment") : 0;
  // ---------------------------------- //
  // Open the input file.
  // ---------------------------------- //
  fd0=open(argv[1],O_RDONLY | O_DIRECT);// Open the input file.
  if (fd0 == -1)                        // Could we open the file ?
    errExit("open");                    // No, that's an error.
  // ---------------------------------- //
  // Memalign() allocates a block of memory aligned on an address that is a 
  // multiple of it's first argument. By specifying this argument as
  // 2*alignment and then adding alignment to the returned pointer, we ensure
  // that 'buf' is aligned on a non-power-of-two-multiple of 'alignment'.
  // We do this to ensure that if, for example, we ask for a 256-byte buffer
  // we don't accidentally get a buffer that is also aligned on a 512-byte boundary.
  // In other words, have more space that doesn't clash with the boundaries of the 
  // harmonics.
  // ---------------------------------- //
  buf=memalign(alignment*2, length + alignment);
  
  if (buf == NULL)                      // Did we align to address we specified ?
    errExit("memalign");                // No, that's an error.
  buf+=alignment;                       // Otherwise expand the buffer a little.
  // ---------------------------------- //
  // Seek in the open file up to the offset.
  // ---------------------------------- //
  if (lseek(fd0, ofs, SEEK_SET) == -1)  // Did we find the bytes at offset?
    errExit("lsek");                    // No, that's an error.
  nBytes=read(fd, buf, len);            // Read this len from fd into buf.
  if (nBytes == -1)                     // Read anything ?
    errExit("read");                    // No, that's an error.
  printf("Read %ld bytes.\n", (long) nBytes);
  
  exit(EXIT_SUCCESS);                   // If we got here, we are good.
  
    
}
